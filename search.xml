<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jmeter踩坑：导入源码二次开发，函数助手添加自定义函数-SHA256加密]]></title>
    <url>%2F2019%2F03%2F19%2FJmeter%E8%B8%A9%E5%9D%91%EF%BC%9A%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%EF%BC%8C%E5%87%BD%E6%95%B0%E5%8A%A9%E6%89%8B%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0-SHA256%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[最近测试的注册、登录接口，密码通过SHA256加密，诸如以前的MD5加密可以直接使用Jmeter函数助手进行加密，SHA256加密没有现成的函数。 在网上搜索了大半天，基本两个路线，一个是通过Beanshell脚本，一个是对Jmeter进行二次开发，自行添加函数，之后使用函数助手进行调用。 效果： 觉得写进函数助手是个一劳永逸的办法，于是开始根据网上搜寻的教程实践。然而，还是遇到了很多坑！！！！毕竟自己是个渣，别人过程一没写全，我就短路了。 实践完了之后发现，也不算难嘛。很多事情都是这样，你做的时候觉得难度挺大，回头来看， 也就这点破事。 一、源码下载Jmeter官网是提供源码下载的：http://jmeter.apache.org/download_jmeter.cgi页面提供当前最新版本下载，历史版本点击下面：选择source:下载对应版本的源码的压缩包，然后解压。 二、IDE的选择IDE，也就是集成开发环境，常见的就是myEclipse、eclipse、IDEA等。eclipse和IDEA的社区版都是免费的。因为需要用到导出部分文件夹为jar包的格式，我在IDEA上找了好久都没找到这个功能，所以踩了一下午坑之后决定转用eclipse了。如果你们谁发现IDEA上的这个功能怎么操作的分享一下。无脑走教程的就选eclipse。 下载：https://www.eclipse.org/downloads/默认进去是win版的，需要mac或linux版的点”Download Packages”进入 三、导入源码1.打开eclipse,这里是eclipse的workspace，简单说就是在eclipse中新建项目会默认存放在这个文件夹下2.新建一个java project写工程名：勾选允许导出3.导入源码右键项目名-Import(忽略上面那个Jmeter，是自己练手做的)选择你解压了Jmeter的目录：导入后可以看到： 你导入之后应该会看到src的文件夹下有红色的小叉，是因为缺少依赖的jar包。（我是因为之前练手时已经添加了依赖包） 4.导入依赖包 一种方式是，把你可执行版（Binaries版）Jmeter里lib目录下的jar包都复制到源码的lib目录下。另一种使用ant框架导入依赖包：双击：download_jars可以从控制台看到下载包的情况 下载jar结束后，项目右键-properties 把这两个文件改为.classpath和.project 可通过终端命令1mv eclipse.classpath .classpath 重启eclipse之后就不会再有红色叉了。 四、二次开发在该目录下，新建一个class文件，SHA256.java复制以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package org.apache.jmeter.functions;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Collection;import java.util.LinkedList;import java.util.List; import org.apache.jmeter.engine.util.CompoundVariable;import org.apache.jmeter.samplers.SampleResult;import org.apache.jmeter.samplers.Sampler;import org.apache.jmeter.threads.JMeterVariables;import org.apache.jmeter.util.JMeterUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory; /* * 对字符串进行SHA256加密 */public class SHA256 extends AbstractFunction &#123; private static final Logger log = LoggerFactory.getLogger(SHA256.class); private static final List&lt;String&gt; desc = new LinkedList&lt;&gt;(); private static final String KEY = &quot;__SHA256&quot;; // Function name static &#123; desc.add(JMeterUtils.getResString(&quot;String to encrypt&quot;)); // 函数助手中显示的参数说明，对应到参数 desc.add(JMeterUtils.getResString(&quot;function_name_paropt&quot;));// 保存函数返回结果的变量，用于引用 &#125; private CompoundVariable strText, varName; @Override public List&lt;String&gt; getArgumentDesc() &#123; return desc; &#125; public SHA256() &#123; &#125; @Override public String execute(SampleResult previousResult, Sampler currentSampler) throws InvalidVariableException &#123; MessageDigest md; String strTmp = strText.execute().trim(); String encodeStr = &quot;&quot;; try &#123; md = MessageDigest.getInstance(&quot;SHA-256&quot;); md.update(strTmp.getBytes(&quot;UTF-8&quot;)); encodeStr = byte2Hex(md.digest()); &#125; catch (NoSuchAlgorithmException ex) &#123; log.error(&quot;String encryption exception&quot;,ex); &#125; catch (UnsupportedEncodingException ex) &#123; log.error(&quot;String encryption exception&quot;,ex); &#125; if (varName != null) &#123; JMeterVariables vars = getVariables(); final String varTrim = varName.execute().trim(); if (vars != null &amp;&amp; varTrim.length() &gt; 0) &#123; vars.put(varTrim, encodeStr); &#125; &#125; return encodeStr; &#125; /** * 将byte转为16进制 * * @param bytes * @return */ private String byte2Hex(byte[] bytes) &#123; StringBuffer stringBuffer = new StringBuffer(); String temp = null; for (int i = 0; i &lt; bytes.length; i++) &#123; temp = Integer.toHexString(bytes[i] &amp; 0xFF); if (temp.length() == 1) &#123; // 1得到一位的进行补0操作 stringBuffer.append(&quot;0&quot;); &#125; stringBuffer.append(temp); &#125; return stringBuffer.toString(); &#125; @Override public void setParameters(Collection&lt;CompoundVariable&gt; parameters) throws InvalidVariableException &#123; // 检查参数数量 checkParameterCount(parameters, 1, 2); Object[] values = parameters.toArray(); strText = (CompoundVariable) values[0]; if (values.length &gt; 1)&#123; varName = (CompoundVariable) values[1]; &#125; else &#123; varName = null; &#125; &#125; @Override public String getReferenceKey() &#123; return KEY; &#125;&#125; 作为一个代码渣，代码是在网上down的，参考：https://blog.csdn.net/y100100/article/details/80701049 五、导入Jmeter右键-导出导出的jar包更名为ApacheJMeter_functions.jar，同时覆盖掉Jmeter\lib\ext（不是源码版，是Binaries版）下的ApacheJMeter_functions.jar，重启jmeter，函数助手里就可以看到SHA256函数了。]]></content>
      <categories>
        <category>Jmeter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jmeter踩坑：响应内容为空/CSV Data Set Config 入参乱码]]></title>
    <url>%2F2019%2F03%2F12%2FJmeter%E8%B8%A9%E5%9D%91%EF%BC%9A%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9%E4%B8%BA%E7%A9%BA%E3%80%81CSV%20Data%20Set%20Config%20%E5%85%A5%E5%8F%82%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[小问题也让人头疼，好记性不如烂笔头。 1. 响应内容为空web端调用这个接口有响应内容，postman调用也有响应内容经历了无数尝试，终于发现因为入参有中文导致的，在Content encoding中填入utf-8就好了 2. CSV Data Set Config 入参乱码CSV Data Set Config 配置.csv文件时，含有中文时，入参就显示如图乱码。设置文件编码格式为UTF-8也没有用。将文件编码格式改为GB2312：不再乱码：]]></content>
      <categories>
        <category>Jmeter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jmeter踩坑：自动化生成测试结果报告]]></title>
    <url>%2F2019%2F03%2F11%2FJmeter%E8%B8%A9%E5%9D%91%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[1. 如何生成测试结果报告？终端执行命令：./jmeter -n -t 要执行的脚本地址.jmx -l 存放jtl结果的地址.jtl -e -o 存放结果报告的文件夹地址 在存放报告的文件夹中index.html就是可视化测试报告。报告如下： 踩坑:该命令要在jmeter的bin目录下执行很多教程都写的是jmeter -n -t开头，实际是./jmeter每次新的测试计划执行都要把之前的结果报告删除，否则新的测试报告不能读入 2. 如何自动化进行？每次都要手动删掉之前的报告，再手动命令，麻烦，自动化脚本走一个。建一个批处理文件，代码如下：（我用的mac，.sh文件，win是.bat，命令可能有差异，但原理就是酱紫）123456789101112#!/bin/sh#删除result.jtlrm -f /Users/xxx/Documents/software/apache-jmeter-4.0/bin/result.jtl#删除ResultReport文件夹rm -rf ResultReport/#新建ResultReport文件夹mkdir ResultReport#执行测试计划./jmeter -n -t /Users/xxx/Documents/Quality/interface_testing/interface.jmx -l /Users/xxx/Documents/software/apache-jmeter-4.0/bin/result.jtl -e -o /Users/xxx/Documents/software/apache-jmeter-4.0/bin/ResultReport 放在bin目录下： 需要执行时，终端在bin目录下：1./jmeter_auto.sh]]></content>
      <categories>
        <category>Jmeter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jmeter踩坑：Beanshell断言判断响应是否为JSON格式]]></title>
    <url>%2F2019%2F03%2F10%2FJmeter%E8%B8%A9%E5%9D%91%EF%BC%9ABeanshell%E6%96%AD%E8%A8%80%E5%88%A4%E6%96%AD%E5%93%8D%E5%BA%94%E6%98%AF%E5%90%A6%E4%B8%BAJSON%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[接口测试初期，先确认接口能否跑通，响应状态码为200，以及响应信息是json格式。Jmeter4.0之后新增了JSON Assertion，可以验证响应是不是json格式。但需同时验证响应状态码是否为200以及响应信息是否为json格式，可使用Jmeter工具添加beanshell断言。 下载json.jar，在测试计划中导入jar包 beanshell断言代码如下，可直接复制粘贴： 12345678910111213141516171819202122import org.json.*;//引入jar包String result = prev.getResponseDataAsString();//获取响应信息code=prev.getResponseCode();//获取响应状态码log.info(code);//打印状态码if(!code.equals(&quot;200&quot;))&#123; log.info(&quot;********状态码炸了********&quot;); Failure = true;//断言失败&#125; Object json = new JSONTokener(result).nextValue();//会给出一个对象，然后可以动态的转换为适当的类型if(json instanceof JSONObject)&#123;//判断其左边对象是否为其右边类的实例，返回boolean类型的数据 log.info(&quot;***是一个jsonObject***&quot;); Failure = false;//断言成功&#125;else if (json instanceof JSONArray)&#123; log.info(&quot;***是一个jsonArray***&quot;); Failure = false;//断言成功 &#125;else&#123; log.error(&quot;************不是一个json*************&quot;); Failure = true;//断言失败 &#125; 踩坑：最开始只想到了JSONObject，于是一片报红，后来发现有的响应是JSONArray，添加了对JSON数组的判断]]></content>
      <categories>
        <category>Jmeter</category>
      </categories>
  </entry>
</search>
