<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[rest-assured接口测试入门-part1]]></title>
    <url>%2F2019%2F03%2F25%2Frest-assured%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-part1%2F</url>
    <content type="text"><![CDATA[一、rest-assured介绍rest-assured是github上一个开源项目。地址：https://github.com/rest-assured/rest-assured作者言： Testing and validation of REST services in Java is harder than in dynamic languages such as Ruby and Groovy. REST Assured brings the simplicity of using these languages into the Java domain. 优点：简约的接口测试DSL支持xml json的结构化解析支持xpath jsonpath gpath等多种解析方式对spring的支持比较全面 二、restassured接口测试步骤 IDEA创建maven项目 添加依赖 restassured junit 编写用例 添加断言 调试 三、demo演练在IDEA中新建一个maven项目，then…… pom.xml文件中添加依赖： 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.rest-assured&lt;/groupId&gt; &lt;artifactId&gt;rest-assured&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; src/test/java下new一个RestDemo.class开源wiki中说需要Static imports一下几个包。即静态导入： 123import static io.restassured.RestAssured.given;import static io.restassured.matcher.RestAssuredMatchers.*;import static org.hamcrest.Matchers.*; 最简单的代码：表示发送一个get请求，url是http://www.baidu.com 1234567public class RestDemo &#123; @Test public void testGetHtml()&#123; //then()是断言，statusCode(200)是响应状态码等于200。 given().get(&quot;http://www.baidu.com&quot;).then().statusCode(200); &#125;&#125; 打印log 123456public class RestDemo &#123; @Test public void testGetHtml()&#123; given().log().all().get(&quot;http://www.baidu.com&quot;).then().log().all().statusCode(200); &#125; //log().all()：打印所有log，可以查看有请求和响应的信息 可以使用这样的格式写：1234567//百度搜索Mp3@Test public void testMp3()&#123; given() .get(&quot;http://www.baidu.com/s?wd=mp3&quot;) .then().log().all().statusCode(200); &#125; restassured最期望的格式：1234567891011 @Test public void testMp3()&#123; given() .queryParam(&quot;wd&quot;,&quot;mp3&quot;) .when() .get(&quot;http://www.baidu.com/s&quot;) .then() .log().all() .statusCode(200); &#125;&#125; given()：一次网络请求所需要的条件都写在这里，头信息、query参数when()：触发条件then()：断言 demo演练：（1）抓取真实接口，以xueqiu.com搜索接口为例（2）new一个Xueqiu.class文件123456789101112public class Xueqiu &#123; @Test public void testSearch() &#123; given() .queryParam(&quot;code&quot;, &quot;sogo&quot;) .when() .get(&quot;https://xueqiu.com/stock/search.json&quot;) .then() .log().all() .statusCode(200); &#125;&#125; （3）run一下，提示错误：（4）打印log,查找错误：通过与f12抓的包对比，发现Cookie没有值：复制抓到的Cookie值现在请求可以正常发送，也有结果返回了，根据结果修改我们的断言。（5）调整断言：断言stocks下面的name值为搜狗：.body(&quot;stocks.name&quot;,hasItems(&quot;搜狗&quot;));stocks.name：根节点.子节点.body() 可以无限的写下去当实际结果不符合断言会怎样呢？假如我们把断言改成“sogo”，让其实际结果不符合预期.body(&quot;stocks.code&quot;,hasItems(&quot;sogo&quot;)) 7.demo演练代码123456789101112131415161718192021222324252627import org.junit.Test;import static io.restassured.RestAssured.given;import static org.hamcrest.Matchers.hasItems;public class Xueqiu &#123; @Test public void testSearch() &#123; //given开头表示输入数据 given().log().all() //query请求参数 .queryParam(&quot;code&quot;, &quot;sogo&quot;) //头信息 .header(&quot;Cookie&quot;,&quot;_ga=GA1.2.506579530.1552574503; device_id=0158c91c7ecd8e4d248a54002af6d8ae; aliyungf_tc=AQAAAIatGzFrQgoAJGDMeOsikkxtPFqv; xq_a_token=682c39a460645dafb1ff41f67e0efccba8b0f118; xq_a_token.sig=Bg9acTC-woVSsS6DZvdAtd40CQU; xq_r_token=798a7cab8cd606f61a09fbac15374f1172b00607; xq_r_token.sig=sHSWFNmu_GqEUOK9A-6umfNgFcU; _gid=GA1.2.841306833.1553178554; Hm_lvt_1db88642e346389874251b5a1eded6e3=1552574504,1552736056,1553178554; u=881553178554746; _gat=1; Hm_lpvt_1db88642e346389874251b5a1eded6e3=1553180196&quot;) //when表示触发条件 .when() .get(&quot;https://xueqiu.com/stock/search.json&quot;) //then对结果断言 .then() //打印log .log().all() //断言状态码 .statusCode(200) //字段断言 .body(&quot;stocks.name&quot;,hasItems(&quot;搜狗&quot;)) .body(&quot;stocks.code&quot;,hasItems(&quot;sogo&quot;)); &#125;&#125;]]></content>
      <categories>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>rest-assured</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter踩坑：导入源码二次开发，函数助手添加自定义函数-SHA256加密]]></title>
    <url>%2F2019%2F03%2F19%2FJmeter%E8%B8%A9%E5%9D%91%EF%BC%9A%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%EF%BC%8C%E5%87%BD%E6%95%B0%E5%8A%A9%E6%89%8B%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0-SHA256%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[最近测试的注册、登录接口，密码通过SHA256加密，诸如以前的MD5加密可以直接使用Jmeter函数助手进行加密，SHA256加密没有现成的函数。 在网上搜索了大半天，基本两个路线，一个是通过Beanshell脚本，一个是对Jmeter进行二次开发，自行添加函数，之后使用函数助手进行调用。 效果： 觉得写进函数助手是个一劳永逸的办法，于是开始根据网上搜寻的教程实践。然而，还是遇到了很多坑！！！！毕竟自己是个渣，别人过程一没写全，我就短路了。 实践完了之后发现，也不算难嘛。很多事情都是这样，你做的时候觉得难度挺大，回头来看， 也就这点破事。 一、源码下载Jmeter官网是提供源码下载的：http://jmeter.apache.org/download_jmeter.cgi页面提供当前最新版本下载，历史版本点击下面：选择source:下载对应版本的源码的压缩包，然后解压。 二、IDE的选择IDE，也就是集成开发环境，常见的就是myEclipse、eclipse、IDEA等。eclipse和IDEA的社区版都是免费的。因为需要用到导出部分文件夹为jar包的格式，我在IDEA上找了好久都没找到这个功能，所以踩了一下午坑之后决定转用eclipse了。如果你们谁发现IDEA上的这个功能怎么操作的分享一下。无脑走教程的就选eclipse。 下载：https://www.eclipse.org/downloads/默认进去是win版的，需要mac或linux版的点”Download Packages”进入 三、导入源码1.打开eclipse,这里是eclipse的workspace，简单说就是在eclipse中新建项目会默认存放在这个文件夹下2.新建一个java project写工程名：勾选允许导出3.导入源码右键项目名-Import(忽略上面那个Jmeter，是自己练手做的)选择你解压了Jmeter的目录：导入后可以看到： 你导入之后应该会看到src的文件夹下有红色的小叉，是因为缺少依赖的jar包。（我是因为之前练手时已经添加了依赖包） 4.导入依赖包 一种方式是，把你可执行版（Binaries版）Jmeter里lib目录下的jar包都复制到源码的lib目录下。另一种使用ant框架导入依赖包：双击：download_jars可以从控制台看到下载包的情况 下载jar结束后，项目右键-properties 把这两个文件改为.classpath和.project 可通过终端命令1mv eclipse.classpath .classpath 重启eclipse之后就不会再有红色叉了。 四、二次开发在该目录下，新建一个class文件，SHA256.java复制以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package org.apache.jmeter.functions;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Collection;import java.util.LinkedList;import java.util.List; import org.apache.jmeter.engine.util.CompoundVariable;import org.apache.jmeter.samplers.SampleResult;import org.apache.jmeter.samplers.Sampler;import org.apache.jmeter.threads.JMeterVariables;import org.apache.jmeter.util.JMeterUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory; /* * 对字符串进行SHA256加密 */public class SHA256 extends AbstractFunction &#123; private static final Logger log = LoggerFactory.getLogger(SHA256.class); private static final List&lt;String&gt; desc = new LinkedList&lt;&gt;(); private static final String KEY = &quot;__SHA256&quot;; // Function name static &#123; desc.add(JMeterUtils.getResString(&quot;String to encrypt&quot;)); // 函数助手中显示的参数说明，对应到参数 desc.add(JMeterUtils.getResString(&quot;function_name_paropt&quot;));// 保存函数返回结果的变量，用于引用 &#125; private CompoundVariable strText, varName; @Override public List&lt;String&gt; getArgumentDesc() &#123; return desc; &#125; public SHA256() &#123; &#125; @Override public String execute(SampleResult previousResult, Sampler currentSampler) throws InvalidVariableException &#123; MessageDigest md; String strTmp = strText.execute().trim(); String encodeStr = &quot;&quot;; try &#123; md = MessageDigest.getInstance(&quot;SHA-256&quot;); md.update(strTmp.getBytes(&quot;UTF-8&quot;)); encodeStr = byte2Hex(md.digest()); &#125; catch (NoSuchAlgorithmException ex) &#123; log.error(&quot;String encryption exception&quot;,ex); &#125; catch (UnsupportedEncodingException ex) &#123; log.error(&quot;String encryption exception&quot;,ex); &#125; if (varName != null) &#123; JMeterVariables vars = getVariables(); final String varTrim = varName.execute().trim(); if (vars != null &amp;&amp; varTrim.length() &gt; 0) &#123; vars.put(varTrim, encodeStr); &#125; &#125; return encodeStr; &#125; /** * 将byte转为16进制 * * @param bytes * @return */ private String byte2Hex(byte[] bytes) &#123; StringBuffer stringBuffer = new StringBuffer(); String temp = null; for (int i = 0; i &lt; bytes.length; i++) &#123; temp = Integer.toHexString(bytes[i] &amp; 0xFF); if (temp.length() == 1) &#123; // 1得到一位的进行补0操作 stringBuffer.append(&quot;0&quot;); &#125; stringBuffer.append(temp); &#125; return stringBuffer.toString(); &#125; @Override public void setParameters(Collection&lt;CompoundVariable&gt; parameters) throws InvalidVariableException &#123; // 检查参数数量 checkParameterCount(parameters, 1, 2); Object[] values = parameters.toArray(); strText = (CompoundVariable) values[0]; if (values.length &gt; 1)&#123; varName = (CompoundVariable) values[1]; &#125; else &#123; varName = null; &#125; &#125; @Override public String getReferenceKey() &#123; return KEY; &#125;&#125; 作为一个代码渣，代码是在网上down的，参考：https://blog.csdn.net/y100100/article/details/80701049 五、导入Jmeter右键-导出导出的jar包更名为ApacheJMeter_functions.jar，同时覆盖掉Jmeter\lib\ext（不是源码版，是Binaries版）下的ApacheJMeter_functions.jar，重启jmeter，函数助手里就可以看到SHA256函数了。]]></content>
      <categories>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter踩坑：响应内容为空/CSV Data Set Config 入参乱码]]></title>
    <url>%2F2019%2F03%2F12%2FJmeter%E8%B8%A9%E5%9D%91%EF%BC%9A%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9%E4%B8%BA%E7%A9%BA%E3%80%81CSV%20Data%20Set%20Config%20%E5%85%A5%E5%8F%82%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[小问题也让人头疼，好记性不如烂笔头。 1. 响应内容为空web端调用这个接口有响应内容，postman调用也有响应内容经历了无数尝试，终于发现因为入参有中文导致的，在Content encoding中填入utf-8就好了 2. CSV Data Set Config 入参乱码CSV Data Set Config 配置.csv文件时，含有中文时，入参就显示如图乱码。设置文件编码格式为UTF-8也没有用。将文件编码格式改为GB2312：不再乱码：]]></content>
      <categories>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter踩坑：自动化生成测试结果报告]]></title>
    <url>%2F2019%2F03%2F11%2FJmeter%E8%B8%A9%E5%9D%91%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[1. 如何生成测试结果报告？终端执行命令：./jmeter -n -t 要执行的脚本地址.jmx -l 存放jtl结果的地址.jtl -e -o 存放结果报告的文件夹地址 在存放报告的文件夹中index.html就是可视化测试报告。报告如下： 踩坑:该命令要在jmeter的bin目录下执行很多教程都写的是jmeter -n -t开头，实际是./jmeter每次新的测试计划执行都要把之前的结果报告删除，否则新的测试报告不能读入 2. 如何自动化进行？每次都要手动删掉之前的报告，再手动命令，麻烦，自动化脚本走一个。建一个批处理文件，代码如下：（我用的mac，.sh文件，win是.bat，命令可能有差异，但原理就是酱紫）123456789101112#!/bin/sh#删除result.jtlrm -f /Users/xxx/Documents/software/apache-jmeter-4.0/bin/result.jtl#删除ResultReport文件夹rm -rf ResultReport/#新建ResultReport文件夹mkdir ResultReport#执行测试计划./jmeter -n -t /Users/xxx/Documents/Quality/interface_testing/interface.jmx -l /Users/xxx/Documents/software/apache-jmeter-4.0/bin/result.jtl -e -o /Users/xxx/Documents/software/apache-jmeter-4.0/bin/ResultReport 放在bin目录下： 需要执行时，终端在bin目录下：1./jmeter_auto.sh]]></content>
      <categories>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter踩坑：Beanshell断言判断响应是否为JSON格式]]></title>
    <url>%2F2019%2F03%2F10%2FJmeter%E8%B8%A9%E5%9D%91%EF%BC%9ABeanshell%E6%96%AD%E8%A8%80%E5%88%A4%E6%96%AD%E5%93%8D%E5%BA%94%E6%98%AF%E5%90%A6%E4%B8%BAJSON%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[接口测试初期，先确认接口能否跑通，响应状态码为200，以及响应信息是json格式。Jmeter4.0之后新增了JSON Assertion，可以验证响应是不是json格式。但需同时验证响应状态码是否为200以及响应信息是否为json格式，可使用Jmeter工具添加beanshell断言。 下载json.jar，在测试计划中导入jar包 beanshell断言代码如下，可直接复制粘贴： 12345678910111213141516171819202122import org.json.*;//引入jar包String result = prev.getResponseDataAsString();//获取响应信息code=prev.getResponseCode();//获取响应状态码log.info(code);//打印状态码if(!code.equals(&quot;200&quot;))&#123; log.info(&quot;********状态码炸了********&quot;); Failure = true;//断言失败&#125; Object json = new JSONTokener(result).nextValue();//会给出一个对象，然后可以动态的转换为适当的类型if(json instanceof JSONObject)&#123;//判断其左边对象是否为其右边类的实例，返回boolean类型的数据 log.info(&quot;***是一个jsonObject***&quot;); Failure = false;//断言成功&#125;else if (json instanceof JSONArray)&#123; log.info(&quot;***是一个jsonArray***&quot;); Failure = false;//断言成功 &#125;else&#123; log.error(&quot;************不是一个json*************&quot;); Failure = true;//断言失败 &#125; 踩坑：最开始只想到了JSONObject，于是一片报红，后来发现有的响应是JSONArray，添加了对JSON数组的判断]]></content>
      <categories>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
      </tags>
  </entry>
</search>
